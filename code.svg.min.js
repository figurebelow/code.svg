"use strict";



class SVGBase {

  constructor (type, values, style) {
    this.type = type;
    this.attributes = {};
    this.style = {};
    this.transform = {};
    this.transform.rotate = {}; // {x,y,deg}
    this.transform.scale = {};  // {x:xdegs, y:ydegs}
    this.transform.skew = {};
    var that = this;
    for (var attr in values) {
      this.attributes[attr] = values[attr];
    }
    for (var opt in style) {
      this.style[opt] = style[opt];
    }
  }

  append (svg) {
    var svgNode = svg.append (this.type);
    for (var key in this.attributes) {
      svgNode.attr (key, this.attributes[key])
    }
    this.genTransform (svgNode);
    for (var style in this.style) {
      svgNode.style (style, this.style[style]);
    }
    return svgNode;
  }

  genTransform (svgNode) {
      var transformStr = "";
      var rotString = this.genRotate ();
      var scaleString = this.genScale ();
      var skeString = this.genSkew ();
      if (!rotString.length && !scaleString.length && !skeString.length)
        return; // do nothing
      else {
        svgNode.attr("transform", rotString + " " + scaleString + " " + skeString);
      }
  }

  genRotate (svgNode) {
    if (this.isRotated())
    {
      return "rotate(" + this.transform.rotate.deg + " " + this.transform.rotate.x + " " + this.transform.rotate.y + ")";
    }
    return "";
  }

  genScale (svgNode) {
    let xscale = 0, yscale = 0, scaleString = "";
    if (this.transform.scale.x != undefined) {
      xscale = this.transform.scale.x;
    }
    if (this.transform.scale.y != undefined) {
      yscale = this.transform.scale.y;
    }
    if (!xscale && !yscale)
      return scaleString; // skip the rest
    if (xscale && yscale) {
      scaleString = "scale(" + xscale + "," + yscale + ")";
    }
    else {
      if (xscale)
        scaleString = "scale(" + xscale + ")";
      else {
          if (yscale)
            scaleString = "scale(" + yscale + ")";
        }
    }
    return scaleString;
  }

  genSkew (svgNode) {
    let skewStr = "";
    if (this.transform.skewX != undefined)
      skewStr = "skewX (" + this.transform.skewX + ") ";
    if (this.skewY != undefined)
      skewStr += "skewY (" + this.transform.skewY + ") ";
    return skewStr;
  }
  // public methods

  removeAttr (attr) {
    delete(this.attributes[attr]);
    return this;
  }

  setAttr (attrs) {
    for (var attr in attrs) {
      this.attributes[attr] = attrs[attr];
    }
    return this;
  }

  sty(attr, val) {
    this.style[attr] = val;
    return this;
  }

  getAttr(attr) {
    return this.attributes[attr];
  }

  clone () {
    throw ("Missing clone() implementation in " + this.type);
  }

  getCenter () {
    throw ("Missing center() implementation in " + this.type);
  }

  moveTo (xyPos, xdif, ydif) {
    throw ("Missing moveTo() implementation in " + this.type);
  }

  rotate (xyPos, deg) {
    this.transform.rotate.x = xyPos.x;
    this.transform.rotate.y = xyPos.y;
    this.transform.rotate.deg = deg;
  }

  isRotated () { return this.transform.rotate.deg != undefined; }
  getRotate () { return this.transform.rotate };

  sca (xfactor, yfactor) {
    this.transform.scale.x = xfactor;
    this.transform.scale.y = yfactor;
    return this;
  }

  ske (xfactor, yfactor) {
    this.transform.skewX = xfactor;
    this.transform.skewY = yfactor;
    return this;
  }
};

class Circle extends SVGBase {

  constructor (values, style) {
    super ("circle", values, style);
  }

  clone () {
    var newElem = new Circle (this.attributes, this.style);
    return newElem;
  }

  getCenter () {
    return {x: this.attributes["cx"], y: this.attributes["cy"]};
  }

  moveTo (x, y) {
    this.setAttr ({cx: x, cy: y});
    return this;
  }
};

class Ellipse extends SVGBase {

  constructor (values, style) {
    super ("ellipse", values, style);
  }

  clone () {
    var newElem = new Ellipse (this.attributes, this.style);
    return newElem;
  }

  getCenter () {
    return {x: this.attributes["cx"], y: this.attributes["cy"]};
  }

  moveTo (x, y) {
    this.setAttr ({cx: x, cy: y});
    return this;
  }

  rot (deg) {
    let center = this.getCenter ();
    super.rotate(center, deg);
    return this;
  }
};

class Group extends SVGBase {

  constructor (values, style) {
    super ("g", values, style);
  }

  clone () {
    var newElem = new Group (this.attributes, this.style);
    return newElem;
  }
}

;



class Line extends SVGBase {

  constructor (x1, y1, x2, y2, style) {
    super ("line", {}, style);
    this.setAttr ({"x1":x1});
    this.setAttr ({"y1": y1});
    this.setAttr ({"x2": x2});
    this.setAttr ({"y2": y2});
  }

  clone () {
    var newElem = new Line (this.attributes, this.style);
    return newElem;
  }

  getCenter () {
    console.log(this)
    return ({x: (this.getAttr ("x1") + this.getAttr ("x2"))/2,
             y: (this.getAttr ("y1") + this.getAttr ("y2"))/2});
  }

  moveTo (xyPos1, xyPos2) {
    this.setAttr({x1: xyPos1.x, y1:xyPos1.y, x2:xyPos2.x, y2:xyPos2.y})
    return this;
  }

  rot (deg) {
    let center = this.getCenter ();
    super.rotate(center, deg);
    return this;
  }
};



;

class Path extends SVGBase {

  constructor (values, style) {
    super ("path", values, style);
  }

  clone () {
    var newElem = new Path (this.attributes, this.style);
    return newElem;
  }

  getCenter () {
    return Functions.NonIntersecPolCenter ();
  }

  moveTo (xyPos1, xyPos2) {
    this.setAttr({x1: xyPos1.x, y1:xyPos1.y, x2:xyPos2.x, y2:xyPos2.y})
    return this;
  }

  rot (deg) {
    let center = this.getCenter ();
    super.rotate(center, deg);
    return this;
  }
};

;

;

class Polyline extends SVGBase {

  constructor (values, style) {
    super ("polyline", values, style);
  }

  clone () {
    var newElem = new Polyline (this.attributes, this.style);
    return newElem;
  }

  getCenter () {

  }

  moveTo (xyPos1, xyPos2) {
    this.setAttr({x1: xyPos1.x, y1:xyPos1.y, x2:xyPos2.x, y2:xyPos2.y})
    return this;
  }

  rot (deg) {
    let center = this.getCenter ();
    super.rotate(center, deg);
    return this;
  }
};

;



class Rect extends SVGBase {

  constructor (values, style) {
    super ("rect", values, style);
  }

  clone () {
    var newRect = new Rect (this.attributes, this.style);
    return newRect;
  }

  getCenter () {
    var x = this.getAttr("x");
    var y = this.getAttr("y");
    var width = this.getAttr("width");
    var height= this.getAttr("height");
    return ({x: x + width/2, y: y + height/2});
  }

  moveTo (xyPos, x, y) {
    var width = this.getAttr("width");
    var height= this.getAttr("height");
    this.setAttr ({x: x+ xyPos.x - width/2, y: y+ xyPos.y - height/2});
    if (this.isRotated())
      this.rot (this.getRotate().deg);
    return this;
  }

  rot (deg) {
    let center = this.getCenter ();
    super.rotate(center, deg);
    return this;
  }
};

;



class Rnd {

  constructor (seed) {
    this.seed = seed;
  }

  val (lower, upper) {
    if (upper == undefined)
    {
      upper = lower; // consider [0,lower]
    }
    var s = Math.sin(this.seed) * 10000;
    this.seed = s - Math.floor(s);
    return Math.floor(this.seed * upper);
  }

  pick (list) {
    let numElems = list.length;
    if (!numElems)
      return null;
    return list[Math.round(this.val(numElems))];
  }

  colorIn (scale, start, end) {
    return D3.scale.linear().domain([1, 16^6]).range(["#000000","#FFFFFF"])(scale);
  }

  getId () {
    var id = "id-";
    for (let i = 0; i < 8; i++)
    {
      id += String.fromCharCode(97 + Math.floor(Math.random() * 26))
    }
    return id;
  }
};

;

class Scene {

  constructor (root, attrs) {
    this.svg = null;
    this.root = root;
    this.children = [];
    this.masks = {};
    this.attributes = {};
    this.defs = [];
    var that = this;
    for (var attr in attrs) {
      this.attributes[attr] = attrs[attr];
    }
  }

  append () {
    this.svg = this.root.append("svg")
        .attr("xmlns:dc", "http://purl.org/dc/elements/1.1/")
        .attr("xmlns:cc", "http://creativecommons.org/ns#")
        .attr("xmlns:rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
        .attr("xmlns:svg", "http://www.w3.org/2000/svg")
        .attr("xmlns", "http://www.w3.org/2000/svg")
        .attr("xmlns:xlink", "http://www.w3.org/1999/xlink")
        .attr("version", "1.1")
        .attr("encoding", "UTF-8")
        .attr("standalone", "no")
        .attr("width", 800)
        .attr("height", 600);

    var that = this;
    var defs = this.svg.append ("defs");

    this.defs.forEach(function (def) {
      def.append(defs)
    });

    for (var maskId in this.masks) {
      var maskRoot = defs.append ("mask").attr ("id", maskId);
      var mask = this.masks[maskId];
      mask.forEach (function (maskElems) {
        maskElems.append (maskRoot);
      });
    }

    this.svg.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 800)
        .attr("height", 600)
        .style("fill", "#f0e9a4");

    this.children.forEach (function (child) {
        child.append (that.svg);
    });
  }

  getSvg() {
    return this.svg
  }

  exportContent () {
    this.append();
    var content = this.root.html();
    content = content.replace(/clippath/g, "clipPath");
    content = content.replace(/lineargradient/g, "linearGradient");
    content = content.replace(/radialgradient/g, "radialGradient");
    return content;
  };

  add (child) { this.children.push (child); }
  addMask (id, def) {
    if (this.masks[id] != undefined)
    {
      this.masks[id].push (def);
    }
    else {
      this.masks[id] = [def];
    }
  }

  addDef (def) {
    this.defs.push(def);
  }
}

