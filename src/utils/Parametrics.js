/**
* @license
* Copyright 2016 Ruben Afonso, ruben@figurebelow.com
* This source code is licensed under the Apache license (see LICENSE file)
**/

"use strict";

class Parametrics {

  /**
   * Returns the points generated by a Butterfly curve
   * @param {object} origin - xymap with coordinates
   * @param {number} scale  - value to scale the points
   * @param {number} lambda - lambda parameter of the curve
   * @param {number} loops  - number of loops to iterate
   */
  static ButterflyCurve (origin, scale, loops, lambda) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let t = 0.0; t < upperLimit; t += stepSize) {
      let e = (Math.exp(Math.cos(t)) - 2*Math.cos(lambda*t) - Math.pow(Math.sin(t/12),5));
      let x = Math.sin(t) * e;
      let y = Math.cos(t) * e;
      points.push({x:x*scale + origin.x, y:y*scale + origin.y});
    }
    return points;
  }

  /**
   * Returns the points generated by a Hypocycloid curve
   * @param {object} origin - xymap with starting coordinates
   * @param {number} r      - minor circle radio
   * @param {number} R      - major circle radio
   * @param {number} loops  - number of loops to iterate
   */
  static Hypocycloid (origin, scale, loops, r, R) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = (R-r) * Math.cos(th) + r*Math.cos(((R-r)/r)*th);
      let y = (R-r) * Math.sin(th) - r*Math.sin(((R-r)/r)*th);
      points.push({x:x*scale + origin.x, y:y*scale + origin.y});
    }
    return points;
  }

  /**
   * Returns the points generated by a Rose curve.
   * The k parameter can be expressed as (n/d), being both integer values
   * @param {object} origin - xymap with starting coordinates
   * @param {number} k      - k factor of the Rose curve (n/d)
   * @param {number} loops  - number of loops to iterate
   */
  static Rose (origin, scale, loops, k) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = Math.cos(k*th) * Math.cos(th);
      let y = Math.cos(k*th) * Math.sin(th);
      points.push ({x:x, y:y});
    }
    return points;
  }
};

module.exports.Parametrics = Parametrics;
